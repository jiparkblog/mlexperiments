<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Machine Learning Experiment</title>
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
  <style>
      /* position:absolute;
  left:0;
  top:0;
  z-index:-1; */
  </style>
</head>

<body>




  <div class="header">
    <p><a href="index.html">Machine Learning Experiments</a></p>
  </div>
  <div class="main">
      <h2>2. <img src="icon.png" style="width:100px">(colors i.e. Red, Blue)</h2>
  </div>
  <div class="result">
  <div id="label-container"></div>
    <canvas class="boops" style="position:absolute;left:0;top:0;z-index: -1;"></canvas>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/speech-commands@0.4.0/dist/speech-commands.min.js"></script>
<script type="text/javascript">

//start tensorflow

let ballcol;


const world = document.querySelector(".boops");
const { Engine, Render, Runner, World, Bodies } = Matter;

function createBall() {
  const ball = Bodies.circle(Math.round(Math.random() * 1280), -30, Math.round(Math.random() * 150)+50, {
    angle: Math.PI * (Math.random() * 2 - 1),
    render: {
         fillStyle: ballcol,
         strokeStyle: ballcol,
         lineWidth: 1
    }

  });


  return ball;
}

const engine = Engine.create();
const runner = Runner.create();
const render = Render.create({
  canvas: world,
  engine: engine,
  options: {
    width: 1280,
    height: 720,
    background: "transparent",
    wireframes: false
  }
});


const boundaryOptions = {
  isStatic: true,
  render: {
    fillStyle: "transparent",
    strokeStyle: "transparent"
  }
};
const ground = Bodies.rectangle(640, 720, 1300, 4, boundaryOptions);
const leftWall = Bodies.rectangle(0, 360, 4, 740, boundaryOptions);
const rightWall = Bodies.rectangle(1280, 360, 4, 800, boundaryOptions);

Render.run(render);
Runner.run(runner, engine);

World.add(engine.world, [ground, leftWall, rightWall]);

const handleClick = () => {
  const ball2 = createBall();
  World.add(engine.world, [ball2]);
};

const button = document.querySelector("#boop");




  // more documentation available at
    // https://github.com/tensorflow/tfjs-models/tree/master/speech-commands

    // the link to your model provided by Teachable Machine export panel
    const URL = "https://teachablemachine.withgoogle.com/models/WerH2egqk/";

    init();

    async function createModel() {
        const checkpointURL = URL + "model.json"; // model topology
        const metadataURL = URL + "metadata.json"; // model metadata

        const recognizer = speechCommands.create(
            "BROWSER_FFT", // fourier transform type, not useful to change
            undefined, // speech commands vocabulary feature, not useful for your models
            checkpointURL,
            metadataURL);

        // check that model and metadata are loaded via HTTPS requests.
        await recognizer.ensureModelLoaded();

        return recognizer;
    }

    async function init() {
        const recognizer = await createModel();
        const classLabels = recognizer.wordLabels(); // get class labels
        const labelContainer = document.getElementById("label-container");
        for (let i = 0; i < classLabels.length; i++) {
            labelContainer.appendChild(document.createElement("div"));
        }

        // listen() takes two arguments:
        // 1. A callback function that is invoked anytime a word is recognized.
        // 2. A configuration object with adjustable fields
        recognizer.listen(result => {
            const scores = result.scores; // probability of prediction for each class
            // render the probability scores per class
            for (let i = 0; i < classLabels.length; i++) {
              let prob=result.scores[i];
              if(prob>0.7){
                if(classLabels[i]=='Red'){
                  ballcol="red"
                  handleClick();
                }else if(classLabels[i]=='Orange'){
                  ballcol="orange"
                  handleClick();
                }else if(classLabels[i]=='Yellow'){
                  ballcol="yellow"
                  handleClick();
                }else if(classLabels[i]=='Green'){
                  ballcol="green"
                  handleClick();
                }else if(classLabels[i]=='Blue'){
                  ballcol="blue"
                  handleClick();
                }else if(classLabels[i]=='Purple'){
                  ballcol="purple"
                  handleClick();
                }else if(classLabels[i]=='Pink'){
                  ballcol="pink"
                  handleClick();
                }else if(classLabels[i]=='Black'){
                  ballcol="black"
                  handleClick();
                }
              }
            }
        }, {
            includeSpectrogram: true, // in case listen should return result.spectrogram
            probabilityThreshold: 0.75,
            invokeCallbackOnNoiseAndUnknown: true,
            overlapFactor: 0.50 // probably want between 0.5 and 0.75. More info in README
        });

        // Stop the recognition in 5 seconds.
        // setTimeout(() => recognizer.stopListening(), 5000);
    }
</script>

  <script src="js/plugins.js"></script>
  <script src="js/main.js"></script>

</body>

</html>
